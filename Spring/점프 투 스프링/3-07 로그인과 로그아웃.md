SBB는 여러 사람이 사용하는 게시판 서비스다. 그러므로 질문한 사람, 답변한 사람을 구별하는 로그인, 로그아웃은 필수 기능이다. 앞서 회원 가입 기능을 구현했으므로 이제 로그인, 로그아웃 기능을 구현할 수 있다.

# 로그인 구현하기
회원 가입 단계에서 SITE_USER 테이블에 회원 정보를 저장했다. SITE_USER 테이블에 저장된 사용자명과 비밀번호로 로그인을 하려면 복잡한 단계를 거쳐야 한다. 하지만 스프링 시큐리티를 사용하면 이 단계를 보다 쉽게 진행할 수 있다.

**스프링 시큐리티는 방대한 프레임워크이다.**
스프링 시큐리티는 방대한 프레임워크이다. 따라서 스프링 시큐리티가 내부적으로 어떻게 동작하는지 알기 위해서는 스프링 시큐리티에 대해서 자세히 공부해야 한다. (스프링 시큐리티는 책 1권 분량으로 나올만큼 방대한 프레임워크이다. 실제로 스프링 시큐리티에 대한 책은 많이 출판되었다.) 이 책은 스프링 시큐리티 자체에 대한 내용보다는 활용적인 측면에 대해서만 다룰 것이다. 하지만 개략적인 개념 설명을 추가했으니 이해에 도움이 되기를 바란다.

# 로그인 URL 등록
먼저 스프링 시큐리티에 로그인 URL을 등록하자

<pre>
<code>
(... 생략 ...)

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    @Bean
    SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests().requestMatchers(
                new AntPathRequestMatcher("/**")).permitAll()
            .and()
                .csrf().ignoringRequestMatchers(
                        new AntPathRequestMatcher("/h2-console/**"))
            .and()
                .headers()
                .addHeaderWriter(new XFrameOptionsHeaderWriter(
                        XFrameOptionsHeaderWriter.XFrameOptionsMode.SAMEORIGIN))
            .and()
                .formLogin()
                .loginPage("/user/login")
                .defaultSuccessUrl("/")
            ;

        return http.build();
    }

    @Bean
    PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
</code>
</pre>

추가한 and().formLogin().loginPage("/user/login").defaultSuccessUrl("/")은 스프링 시큐리티의 로그인 설정을 담당하는 부분으로 로그인 페이지의 URL은 /user/login이고 로그인 성공시에 이동하는 디폴트 페이지는 루트 URL "/"임을 의미한다.

# UserController

스프링 시큐리티에 로그인 URL을 /user/login으로 설정했으므로 User 컨트롤러에 해당 매핑을 추가해야 한다. 

<pre>
<code>
(... 생략 ...)
public class UserController {

    (... 생략 ...)

    @GetMapping("/login")
    public String login() {
        return "login_form";
    }
}
</code>
</pre>

login_form.html 템플릿을 렌더링하는 GET 방식의 login 메서드를 추가했다. 실제 로그인을 진행하는 @PostMapping 방식의 메서드는 스프링 시큐리티가 대신 처리하므로 직접 구현할 필요가 없다.

# login_form.html

![image](https://user-images.githubusercontent.com/74352543/221734870-405cc37e-139e-4fd1-bd2f-a647d46ccc86.png)

사용자 ID와 비밀번호로 로그인을 할 수 있는 로그인 템플릿을 작성했다. 시큐리티의 로그인이 실패할 경우에는 로그인 페이지로 다시 리다이렉트 된다. 이 때 페이지 파라미터로 error가 함께 전달된다. 따라서 로그인 페이지의 파라미터로 error가 전달될 경우 "사용자ID 또는 비밀번호를 확인해주세요."라는 오류메시지를 출력하도록 했다.

로그인 실패시 파라미터로 error가 전달되는 것은 스프링 시큐리티의 규칙이다.

여기까지 수정하고 브라우저에서 http://localhost:8080/user/login을 호출해 보자. 그러면 다음과 같은 화면이 나타난다.

![image](https://user-images.githubusercontent.com/74352543/221736506-562b257c-21d4-45a3-ba89-ea9377880ed1.png)

하지만 아직 로그인을 수행할 수는 없다. 왜냐하면 스프링 시큐리티에 무엇을 기준으로 로그인을 해야 하는지 아직 설정하지 않았기 때문이다. 스프링 시큐리티를 통해 로그인을 수행하는 방법에는 여러가지가 있다. 예를 들어 가장 간단하게는 시큐리티 설정 파일에 직접 아이디, 비밀번호를 등록하여 인증을 처리하는 메모리 방식이 있다. 하지만 우리는 이미 이전 장에서 회원가입을 통해 회원 정보를 데이터베이스에 저장했으므로 데이터베이스에서 회원정보를 조회하는 방법을 사용해야 할 것이다.

이제 데이터베이스에서 사용자를 조회하는 서비스(UserSecurityService)를 만들고 그 서비스를 스프링 시큐리티에 등록하는 방법에 대해서 알아보자. 하지만 UserSecurityService를 만들고 등록하기 전에 UserSecurityService에서 필요한 UserRepository, UserRole 등을 먼저 준비해야 한다.

# UserRepository
앞으로 작성할 UserSecurityService는 사용자를 조회하는 기능이 필요하므로 다음처럼 findbyusername 메서드를 User 리포지토리에 추가하자

<pre>
<code>
package com.mysite.sbb.user;

import java.util.Optional;

import org.springframework.data.jpa.repository.JpaRepository;

public interface UserRepository extends JpaRepository<SiteUser, Long> {
    Optional<SiteUser> findByusername(String username);
}
</code>
</pre>

# UserRole
스프링 시큐리티는 인증 뿐만 아니라 권한도 관리한다. 따라서 인증후에 사용자에게 부여할 권한이 필요하다. 다음과 같이 ADMIN, USER 2개의 권한을 갖는 UserRole을 신규로 작성하자

<pre>
<code>
package com.mysite.sbb.user;

import lombok.Getter;


@Getter
public enum UserRole {
    ADMIN("ROLE_ADMIN"),
    USER("ROLE_USER");

    UserRole(String value) {
        this.value = value;
    }

    private String value;
}
</code>
</pre>

UserRole은 열거 자료형(enum)으로 작성했다. ADMIN은 "ROLE_ADMIN", USER은 "ROLE_USER"라는 값을 가지도록 했다. 그리고 상수 자료형이므로 @Setter없이 @Getter만 사용하도록 했다.

이 책에서 구현할 SBB는 권한으로 특정 기능을 제어하지 않는다. 하지만 SBB 서비스를 완성하고 다른 사람이 작성한 질문이나 답변을 ADMIN 권한을 지닌 사용자는 수정이 가능하도록 만들어도 좋을 것이다.

# UserSecuritySerive

그리고 스프링 시큐리티 설정에 등록할 UserSecurityService를 다음과 같이 신규로 작성하자.

<pre>
<code>
package com.mysite.sbb.user;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
@Service
public class UserSecurityService implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Optional<SiteUser> _siteUser = this.userRepository.findByusername(username);
        if (_siteUser.isEmpty()) {
            throw new UsernameNotFoundException("사용자를 찾을수 없습니다.");
        }
        SiteUser siteUser = _siteUser.get();
        List<GrantedAuthority> authorities = new ArrayList<>();
        if ("admin".equals(username)) {
            authorities.add(new SimpleGrantedAuthority(UserRole.ADMIN.getValue()));
        } else {
            authorities.add(new SimpleGrantedAuthority(UserRole.USER.getValue()));
        }
        return new User(siteUser.getUsername(), siteUser.getPassword(), authorities);
    }
}
</code>
</pre>

스프링 시큐리티에 등록하여 사용할 UserSecurityService는 스프링 시큐리티가 제공하는 UserDetailService 인터페이스를 구현해야 한다. 스프링 시큐리티의 UserDetailsService는 loadUserByUsername 메서드를 구현하도록 강제하는 인터페이스이다. loadUserByUsername 메서드는 사용자명으로 비밀번호를 조회하여 리턴하는 메서드이다.

UserSecurityService는 스프링 시큐리티 로그인 처리의 핵심 부분이다.

조금더 살펴보면, loadUserByUsername 메서드는 사용자명으로 SiteUser 객체를 조회하고 만약 사용자명에 해당하는 데이터가 없을 경우 UsernameNotFoundException 오류를 내게 했다. 그리고 사용자명이 "admin"인 경우에는 ADMIN 권한을 부여하고 그 이외의 경우에 USER 권한을 부여했다. 그리고 사용자명, 비밀번호, 권한을 입력으로 스프링 시큐리티의 User 객체를 생성하여 리턴했다. 스프링 시큐리티는 loadUserByUsername 메서드에 의해 리턴된 User 객체의 비밀번호가 화면으로부터 입력 받은 비밀번호와 일치하는지를 검사하는 로직을 내부적으로 가지고 있다.

# SecurityConfig
그리고 다음처럼 스프링 시큐리티에 UserSecurityService를 등록하자.

<pre>
<code>
(... 생략 ...)
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
(... 생략 ...)

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    (... 생략 ...)

    @Bean
    AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }
}
</code>
</pre>

AuthenticationManager 빈을 생성했다. AuthenticationManager는 스프링 시큐리티의 인증을 담당한다. AuthenticationManager 빈 생성시 스프링의 내부 동작으로 인해 위에서 작성한 UserSecurityService와 PasswordEncoder가 자동으로 설정된다.

# navbar.html

그리고 마지막으로 로그인 페이지에 진입할 수 있는 로그인 링크를 네비게이션바에 다음과 같이 추가하자

![image](https://user-images.githubusercontent.com/74352543/221758178-b2309afd-feb4-4aab-a0f0-8acbd84b9154.png)


이제 내비게이션 바의 "로그인" 링크를 누르면 /user/login으로 이동하며, 다음과 같은 로그인 화면이 나타날 것이다.

![image](https://user-images.githubusercontent.com/74352543/221758186-d362c984-fbbe-47f5-b7ff-4b784d3e2964.png)

만약 데이터베이스에 없는 username 또는 잘못된 password를 입력하면 다음처럼 오류 메시지가 나타난다.

![image](https://user-images.githubusercontent.com/74352543/221758214-2e88eaec-83ec-4ac4-a875-ad3cad728132.png)

username과 password를 제대로 입력하면 로그인이 정상 수행되고 메인 화면으로 이동할 것이다.

# 로그인 / 로그아웃 링크
하지만 로그인한 후에도 내비게이션 바에는 여전히 "로그인" 링크가 남아 있다. 로그인을 한 상태라면 이 링크는 "로그아웃" 링크로 바뀌어야 한다.

반대로 로그아웃 상태에서는 "로그인" 링크로 바뀌어야 한다.

사용자의 로그인 여부는 타임리프의 sec:authorize 속성을 통해 알수 있다.

* sec:authorize="isAnonymous()" - 이 속성은 로그인 되지 않은 경우에만 해당 엘리먼트가 표시되게 한다.
* sec:authorize="isAuthenticated()" - 이 속성은 로그인 된 경우에만 해당 엘리먼트가 표시되게 한다.

![image](https://user-images.githubusercontent.com/74352543/221758485-6b50867c-95a3-4fd5-8e23-3776b1f9e538.png)

로그인을 안한 상태라면 sec:authorize="isAnonymous()"가 참이되어 "로그인" 링크가 표시되고 로그인을 한 상태라면 sec:authorize="isAuthenticated()"가 참이되어 "로그아웃" 링크가 표시될 것이다.

이제 로그인을 정상적으로 수행하면 다음처럼 "로그아웃" 링크가 표시되는 것을 확인할 수 있다.

![image](https://user-images.githubusercontent.com/74352543/221758645-a1d278c1-c4c4-46bf-ab0b-72bfd58e3bc8.png)

로그아웃 링크는 /user/logout으로 지정했다. 하지만 로그아웃 기능은 아직 구현하지 않은 상태이다. 로그아웃 기능은 바로 이어서 진행한다.

# 로그아웃 구현하기

로그인을 통해 로그인을 했다면 내비게이션 상단에 "로그아웃" 링크가 나타날 것이다. 하지만 "로그아웃" 링크르 누르면 다음과 같이 404 오류 페이지가 표시된다.

![image](https://user-images.githubusercontent.com/74352543/221759084-2ade34da-a6a2-44f8-b908-85c33a08650b.png)

아직 로그아웃 기능을 구현하지 않았기 때문이다. 로그아웃 역시 스프링 시큐리티를 사용하여 쉽게 구현할 수 있다.

# SecurityConfig

다음과 같이 SecurityConfig 파일을 수정하자.

![image](https://user-images.githubusercontent.com/74352543/221759158-0ffd9b62-c05c-421c-a1af-fe3b30b4d397.png)

로그아웃을 위한 설정을 추가했다. 로그아웃 URL을 /user/logout으로 설정하고 로그아웃이 성공하면 루트(/) 페이지로 이동하도록 했다. 그리고 로그아웃시 생성된 사용자 세션도 삭제하도록 처리했다.

수정을 완료한 후 로그인, 로그아웃 기능이 잘 실행되는지 확인해 보자.

로그아웃을 누르면 네비게이션 바에는 다시 "로그인" 링크가 나타날 것이다.



<pre>
<code>

</code>
</pre>
